/*
 * Copyright Â© 2024 Kaleido, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

configurations {
    // Resolvable configurations
    contractCompile {
        canBeConsumed = false
        canBeResolved = true
    }
    zetoArtifacts {
        canBeConsumed = false
        canBeResolved = true
    }
    poseidonArtifacts {
        canBeConsumed = false
        canBeResolved = true
    }
}

dependencies {
    contractCompile project(path: ":solidity", configuration: "compiledContracts")
    zetoArtifacts project(path: ":domains:zeto", configuration: "zetoArtifacts")
    poseidonArtifacts project(path: ":domains:zeto", configuration: "poseidonArtifacts")
}

ext {
    clusterName = project.hasProperty('clusterName') ? project.clusterName : 'paladin' 
    namespace = project.hasProperty('namespace') ? project.namespace : 'default' // Default namespace is 'default' 
    deleteCluster = project.hasProperty('deleteCluster') ? project.deleteCluster.toBoolean() : false // By default, do not delete the cluster
    buildPaladin = project.hasProperty('buildPaladin') ? project.buildPaladin == 'true' : true // Default is to build Paladin
    buildOperator = project.hasProperty('buildOperator') ? project.buildOperator == 'true' : true // Default is to build the operator
}

def printClusterStatus(String namespace) {
    def getAllCommand = ["kubectl", "get", "all", "-n", namespace]
    def getAllProcess = getAllCommand.execute()
    getAllProcess.waitFor()
    println getAllProcess.in.text.trim()
} 

def verifyResourceCreated(String namespace, String resourceType, String resourceName, int timeoutSeconds = 60) {
    
    // Wait for resource creation
    def existsCommand = ["kubectl", "wait", "--for=create", "${resourceType}", "${resourceName}", "-n", namespace, "--timeout=${timeoutSeconds}s"]
    def existsProcess = existsCommand.execute()
    existsProcess.waitFor()
    println "Creation Output: ${existsProcess.text}"

    if (existsProcess.exitValue() != 0) {
        printClusterStatus(namespace)
        throw new Exception("Resource ${resourceType}/${resourceName} (${namespace}) was not created within the expected time.")
    }
}

def verifyResourceReady(String namespace, String resourceType, String resourceName, String condition, int timeoutSeconds = 60) {

    // Wait for resource to meet expected condition
    def waitCommand = ["kubectl", "wait", "--for=${condition}", "${resourceType}", "${resourceName}", "-n", namespace, "--timeout=${timeoutSeconds}s"]
    def waitProcess = waitCommand.execute()
    waitProcess.waitFor()
    println "Wait Output: ${waitProcess.text}"

    if (waitProcess.exitValue() != 0) {
        printClusterStatus(namespace)
        throw new Exception("Resource ${resourceType}/${resourceName} (${namespace}) was not ready in the expected time.")
    }
    printClusterStatus(namespace)
}

task copySolidity(type: Copy, dependsOn: [":domains:noto:copySolidity"]) {
    inputs.files(configurations.contractCompile)
    from fileTree(configurations.contractCompile.asPath) {
        include 'contracts/registry/IdentityRegistry.sol/IdentityRegistry.json'
        include 'contracts/domains/noto/NotoFactory.sol/NotoFactory.json'
        include 'contracts/domains/pente/PenteFactory.sol/PenteFactory.json'
        include 'contracts/private/NotoTrackerERC20.sol/NotoTrackerERC20.json'
        include 'contracts/testcontracts/ERC20Simple.sol/ERC20Simple.json'
        include 'contracts/shared/BondTrackerPublic.sol/BondTrackerPublic.json'
        include 'contracts/private/BondTracker.sol/BondTracker.json'
        include 'contracts/private/BondSubscription.sol/BondSubscription.json'
    }
    into 'test/e2e/abis'

    // Flatten all paths into the destination folder
    eachFile { path = name }
    includeEmptyDirs = false
}

task copyZetoSolidity(type: Copy) {
    inputs.files(configurations.zetoArtifacts)
    inputs.files(configurations.poseidonArtifacts)
    inputs.files(configurations.contractCompile)
    from fileTree(configurations.zetoArtifacts.asPath) {
        include 'artifacts/contracts/**/*.json'
        include 'artifacts/@iden3/contracts/**/*.json'
        exclude '**/*.dbg.json'
    }
    from fileTree(configurations.poseidonArtifacts.asPath) {
        include 'Poseidon2.json'
        include 'Poseidon3.json'
    }
    from fileTree(configurations.contractCompile.asPath) {
        include 'contracts/registry/IdentityRegistry.sol/IdentityRegistry.json'
        include 'contracts/domains/zeto/ZetoFactory.sol/ZetoFactory.json'
    }
    into 'test/e2e/abis/zeto'

    // Flatten all paths into the destination folder
    eachFile { path = name }
    includeEmptyDirs = false
}

task buildContractSamples(type: Exec, dependsOn: [copySolidity, copyZetoSolidity]) {
    commandLine "go", "run", "./contractpkg", "./contractpkg/contract_map.json", "true"
}

// Task to build the Paladin image from the parent project
task buildPaladinImage {
    dependsOn ':docker' // Builds the Paladin image in the parent project
}

// Task to build the operator Docker image
task docker(type: Exec) {
    executable 'make'
    args 'docker-build'
}

// Task to build the Paladin image from the parent project
task buildOperatorImage {
    dependsOn ':operator:docker' // Builds the Paladin image in the parent project
}

// Task to start the Kind cluster
task startKindCluster(type: Exec) {
    executable 'make'
    args 'kind-start'
    args "CLUSTER_NAME=${clusterName}"
}

// Task to load images into the Kind cluster
task promoteKindImages(type: Exec, dependsOn: [
    startKindCluster
]) {
    if (buildPaladin) {
        dependsOn buildPaladinImage
    }
    if (buildOperator) {
        dependsOn buildOperatorImage
    }
    executable 'make'
    args 'kind-promote'
    args "CLUSTER_NAME=${clusterName}"
}

task prepareCRDsChart(type: Exec) {
    executable 'make'
    args 'prepare-crd-chart'
}

// Task to install Helm CRDs
task installCrds(type: Exec, dependsOn: [startKindCluster, prepareCRDsChart]){
    executable 'make'
    args 'install-crds'
}

task prepareOperatorChart(type: Exec, dependsOn: [buildContractSamples]) {
    executable 'make'
    args 'prepare-operator-chart'
}

// Task to install the operator using Helm
task installOperator(type: Exec, dependsOn: [installCrds, promoteKindImages, prepareOperatorChart]) {
    executable 'make'
    args 'helm-install'
    args "NAMESPACE=${namespace}"
}


// Task to verify the operator is running in the 'paladin' namespace
task verifyOperator(dependsOn: installOperator) {
    doLast {
        println 'Waiting for operator deployment to become ready...'
        verifyResourceReady(namespace, 'deployment', 'paladin-operator', 'condition=available')
    }
}

// // Task to create the nodes
// task createNode(type: Exec, dependsOn: verifyOperator) {
//     executable 'make'
//     args 'create-node'
//     args "NAMESPACE=${namespace}"
// }

// // Task to verify the besu statefulSet
// task verifyBesu(dependsOn: createNode) {
//     doLast {
//         println 'Waiting for besu statefulSet to become ready...'

//         verifyResourceCreated(namespace, 'statefulset', 'besu-node1', 120)
//         verifyResourceReady(namespace, 'statefulset', 'besu-node1', 'jsonpath=.status.readyReplicas=1', 60)
//     }
// }

// // Task to verify the paladin statefulSet
// task verifyPaladin(dependsOn: createNode) {
//     doLast {
//         println 'Waiting for paladin statefulSet to become ready...'

//         verifyResourceCreated(namespace, 'statefulset', 'paladin-node1', 120)
//         verifyResourceReady(namespace, 'statefulset', 'paladin-node1', 'jsonpath=.status.readyReplicas=1', 60)
//     }
// }

// The 'deplay' runs the whole flow
task deploy(dependsOn: [copySolidity, copyZetoSolidity, verifyOperator]) {
    doLast {
        println 'Deplopy setup completed. Operator is running in the paladin namespace.'
    }
}

// The 'e2e' task runs the whole flow
task e2e(type: Exec, dependsOn: [buildContractSamples, deploy]) {
    executable 'make'
    args 'test-e2e'
    args "NAMESPACE=${namespace}"
    args "CLUSTER_NAME=${clusterName}"
}

 
// Task to clean up resources
task cleanCluster(type: Exec) {
    executable 'make'
    args 'clean'
    args "NAMESPACE=${namespace}"
    args "DELETE_CLUSTER=${deleteCluster}"
    args "CLUSTER_NAME=${clusterName}"
}

task clean {
    dependsOn cleanCluster
}

// Existing 'make' task
task make(type: Exec, dependsOn: [copySolidity, ":toolkit:go:protoc"]) {
    executable 'make'
}

task build {
    // Default 'build' task just builds as part of the main Paladin build.
    // The operator primary build and test is all docker, and runs in separate builds
    dependsOn make
}

// Task to update the Paladin image in the Kind cluster
task updatePaladinImage(type: Exec) {
    doFirst {
        buildOperator = false
        buildPaladin = true
    }
    dependsOn promoteKindImages 
    executable 'kubectl'
    args "rollout" 
    args "restart" 
    args "sts"
    args "paladin-node1"
    args "paladin-node2"
    args "paladin-node3"
}