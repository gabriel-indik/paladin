/*
 * Copyright Â© 2024 Kaleido, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

syntax = "proto3";

package io.kaleido.paladin.toolkit;

// **CONFIGURE** happens once when the domain is loaded into Paladin
message ConfigureDomainRequest {
  string name = 1; // The name
  string config_json= 2; // The block of config supplied in the configuration for the domain by the Paladin administrator (converted from YAML to JSON for domain)
  string registry_contract_address = 3;  // The address of the registry smart contract
  int64 chain_id = 4; // The chain_id of the underlying base ledger on which all smart contracts are deployed
}

message ConfigureDomainResponse {
  DomainConfig domain_config = 1; // Information that Paladin will use to govern its behavior with repspect to this domain
}

// **INIT** happens once when the domain is loaded into Paladin, after the result of ConfigureDomain has been processed
message InitDomainRequest {
  repeated StateSchema abi_state_schemas = 1; // The deterministically hashed identifiers of the same array of schemas provied to Paladin in the DomainConfig
}

message InitDomainResponse {    
}

// **INIT DEPLOY** step for a deploy transasctio happens in-line with the deploy being accepted by Paladin from the application. Should verify the transaction is a valid request and build the list of required verifiers for the prepare phase.
message InitDeployRequest {
  DeployTransactionSpecification transaction = 1;
}

message InitDeployResponse {
  repeated ResolveVerifierRequest required_verifiers = 1; // the list of verifiers that need to be resolved in order to prepare the transaction (such as issuers/notaries that have privledge in the smart contract)
}

// **PREPARE DEPLOY** once the verifiers have been resolved, the deploy transaction can be prepared directly (no private state proposals or proofs)
message PrepareDeployRequest {
  DeployTransactionSpecification transaction = 1; // The instruction for submission to the base ledger
  repeated ResolvedVerifier resolved_verifiers = 2; // The list of resovled verifiers
}

message PrepareDeployResponse {
  optional string signer = 1; // The identifier of a signing address to use to submit the transaction to the chain. Default behavior if not supplied defined by domain config. Uses standard Paladin resolution of signing addresses (including dynamic allocation, if for example the transaction_id is supplied as part of the string to require a different key for each TX)
  optional BaseLedgerTransaction transaction = 2; // The instruction for a transaction to submit to the base ledger
  optional BaseLedgerDeployTransaction deploy = 3; // The instruction for deploy request to submit to the base ledger
}

// **INIT** step for a business transaction happens in-line with the tranaction being accepted by Paladin from the application. Should verify the transaction is a valid request and build a list of required verifiers, but not resolve whether sufficient states exist to execute the transaction.
message InitTransactionRequest {
  TransactionSpecification transaction = 1; // The transaction to plan
}

message InitTransactionResponse {
  repeated ResolveVerifierRequest required_verifiers = 1; // the list of verifiers that need to be resolved in order to prepare the transaction (such as issuers/notaries that have privledge in the smart contract)
}

// **ASSEMBLE** step happens after plan, once any verifiers specified as needing pre-emptive resolution by the owning Paladin nodes have been resolved successfully. At this step the state store should be queried to determine if sufficient states exist to execute
message AssembleTransactionRequest {
  TransactionSpecification transaction = 1; // The transaction to assemble
  repeated ResolvedVerifier resolved_verifiers = 2; // A list of transaction signatures/proofs that have been resolved, so the transaction can be assembled
}

message AssembleTransactionResponse {
  enum Result {
      OK = 0; // the transaction was assembled successfuly, and the 
      PARK = 1; // the states necessary to resolve the transaction are not currently available, so this transaction must be parked until states become available
      REVERT = 2; // enough states were obtained to execute the transaction according to the business rules, but there was a revert/error condition raised during execution that means this transaction cannot succeed
  }    
  Result assembly_result = 1; 
  optional AssembledTransaction assembled_transaction = 2; // the assembled transaction
  repeated AttestationRequest attestation_plan = 3; // the plan that needs to be executed to gather attestations before preparation - that might include resolving more verifiers and re-verifying assembly
  optional string revert_reason = 4; // if the result was REVERT
}

// **GET_VERIFIER** step only happens when signing is requested with a "domain:" scoped algorithm, and it is enabled for this domain in the Paladin configuration
message GetVerifierRequest {
  string algorithm = 1;
  string verifier_type = 2;
  bytes private_key = 3;
}

message GetVerifierResponse {
  string verifier = 1;
}

// **SIGN** step only happens when signing is requested with a "domain:" scoped algorithm, and it is enabled for this domain in the Paladin configuration
message SignRequest {
  string algorithm = 1;
  string payload_type = 2;
  bytes private_key = 3;
  bytes payload = 4;
}

message SignResponse {
  bytes payload = 1;
}

// **ENDORSE** step happens upon instruction from the attestation plan output from ASSEMBLE
message EndorseTransactionRequest {
  AttestationRequest endorsement_request = 1; // The attestation request from the attestation plan
  ResolvedVerifier endorsement_verifier = 2; // The resolved verifier requested to be used for endorsement
  TransactionSpecification transaction = 3; // The transaction specified by the user
  repeated ResolvedVerifier resolved_verifiers = 4; // The list of resovled verifiers
  repeated EndorsableState inputs = 5; // Input states for the transaction
  repeated EndorsableState reads = 6; // States relied upon by the transaction, that are not actually consumed
  repeated EndorsableState outputs = 7; // Output states for the transaction
  repeated AttestationResult signatures = 8; // All SIGN attestation results (required from submitting node before endorsement)
}

message EndorseTransactionResponse {
  enum Result {
      SIGN = 0; // the endorsement resulted in a payload that should be signed
      ENDORSER_SUBMIT = 1; // the endorsement resulted in a local approval, and a requirement that the endorsement verifier identity must submit the underlying base ledger TX
      REVERT = 2; // the edorsement failed
  }
  Result endorsement_result = 1;
  optional bytes payload = 2; // payload to be signed (if the result was SIGN)
  optional string revert_reason = 3; // revert reason (if the result was REVERT)
}

// **PREPARE** step for a transaction 
message PrepareTransactionRequest {
  TransactionSpecification transaction = 1; // The transaction specified by the user
  repeated EndorsableState input_states = 2; // The list of input states
  repeated EndorsableState read_states = 3; // The list of read states
  repeated EndorsableState output_states = 4; // The list of output states
  repeated AttestationResult attestation_result = 5; // The results of any proofs/attestations that came out of the endorsement phase
  optional string extra_data = 6; // Any extra data that was included in the transaction assembly
}

message PrepareTransactionResponse {
  BaseLedgerTransaction transaction = 1; // The instruction for submission to the base ledger
}

// **EVENTS** handler called with batches of blockchain events that match an event signature and contract address registered by this domain

message HandleEventBatchRequest {
  string batch_id = 1; // A unique identifier for this batch
  ContractInfo contract_info = 2; // The configuration of the contract that emitted the batch of events
  repeated OnChainEvent events = 3; // The list of events from the block indexer
}

message HandleEventBatchResponse {
  repeated CompletedTransaction transactions_complete = 1; // A list of Paladin transactions that may be considered complete
  repeated StateUpdate spent_states = 2; // A list of states that are now spent
  repeated StateUpdate confirmed_states = 3; // A list of states that are now confirmed (and unspent)
  repeated NewLocalState new_states = 4; // A list of new states to store (only for events that contain full state data)
}

message DomainConfig {
  repeated string abi_state_schemas_json = 1; // A list of Schema definitions (in ABI parameter format) the domain requires for all state types it interacts with
  BaseLedgerSubmitConfig base_ledger_submit_config = 2; // Describe the requirements of this domain for how submission happens
  string abi_events_json = 3; // ABI events that the domain will process for state updates
  map<string, int32> signing_algorithms = 4; // A list of supported signing algorithms with the minimum key lengths for each algorithm
}

message BaseLedgerSubmitConfig {
  enum Mode {
      ONE_TIME_USE_KEYS = 0; // every TX is submitted by a different key, with a HD wallet path from the UUID of the TX itself
      ENDORSER_SUBMISSION = 1; // one of the endorsers of the transaction should submit the TX (that endorser might specify ENDORSER_SUBMIT)
      SUBMITTER_LIST = 2; // TODO: a bank of submitters are provided by the domain config/runtime as candidates to submit transactions
  }
  Mode submit_mode = 1;
  string one_time_use_prefix = 2;
}

message StateSchema {
  string id = 1; // A hash derived schema identifier
  string signature = 2; // A readable signature for the schema
}

message DeployTransactionSpecification {
  string transaction_id = 1; // A UUID for the transaction generated by the Paladin node when accepting the request from the caller
  string constructor_params_json = 2; // The parameters supplied in the invocation in normalized JSON format, after validation against the ABI the caller supplied
}

message TransactionSpecification {
  string transaction_id = 1; // A 32 byte 0x prefxied hex string containing unique identifier for the transaction generated by the Paladin node when accepting the request from the caller (UUID in first 16 bytes)
  string from = 2; // The unresolved sender identity - the instruction for how to resolve it will be an output of the TX init from 
  ContractInfo contract_info = 3;
  string function_signature = 4; // The calculated signature of the function ABI the caller is attempting to invoke
  string function_abi_json = 5; // The function ABI (asserted by the caller) they wish to inovoke on the smart contract
  string function_params_json = 6; // The parameters supplied in the invocation in normalized JSON format, after validation against the ABI the caller supplied
  int64 base_block = 7; // The block number on the base ledger, upon which this transaction is being assembled
}

message AssembledTransaction {
  repeated StateRef input_states = 1; // A list of the state IDs that the transaction spends - these might include ones being minted on other sequences, resulting in an instruction to the TX manager to re-allocate the transaction to another sequence
  repeated StateRef read_states = 2; // A list of state IDs that the execution of the transaction depends on being unspent on the chain (but will not spend). Also could be being minted on other sequences.
  repeated NewState output_states = 3; // A list of new states the domain will create as an output from this transaction, if it is executed and confirmed
  optional string extra_data = 4; // Any extra data to be included in the transaction (other than states)
}

message StateRef {
  string id = 1; // The hash id calculated by the local node for this state
  string schema_id = 2; // The id from the schema, which must be one of the ones established during the ConfigDomain+InitDomain phase
}

message StateUpdate {
  string id = 1; // The hash id calculated by the local node for this state
  string transaction_id = 2; // The UUID for the transaction generated by the Paladin node
}

message NewState {
  string schema_id = 1; // The id from the schema, which must be one of the ones established during the ConfigDomain+InitDomain phase
  string state_data_json = 2; // The data for this state that will be recorded by Paladin, and uniquely identified by Paladin using a hash (which might be additional to any hashing done in a unique way by the domain)
  repeated string distribution_list = 3; // A list of Paladin recipients that should receive a copy of this state in parallel to transaction submission, once it has been successfully prepared
  optional string id = 4; // The hash id to uniquely identify this state (a default hashing algorithm will be used by Paladin if omitted)
}

message NewLocalState {
  string schema_id = 1; // The id from the schema, which must be one of the ones established during the ConfigDomain+InitDomain phase
  string state_data_json = 2; // The data for this state that will be recorded by Paladin, and uniquely identified by Paladin using a hash (which might be additional to any hashing done in a unique way by the domain)
  string transaction_id = 3; // The UUID for the transaction generated by the Paladin node
  optional string id = 4; // The hash id to uniquely identify this state (a default hashing algorithm will be used by Paladin if omitted)
}

message EndorsableState {
  string id = 1; // The hash id calculated by the local node for this state
  string schema_id = 2; // The id from the schema
  string state_data_json = 3; // The data for this state that will be ensured to be committed to the local DB before sending an edorsement confirmations
}

// The attestation types must occur in the order listed here, in the attestation_plan
enum AttestationType {
  SIGN = 0; // Occurs before the transaction is considered fully assembled - gathers a signature against the state inputs+outputs of the transaction, including proof of knowledge of the private data. Use to authenticate an action, such as a transfer, that will be endorsed by other parties
  ENDORSE = 1; // A verification of the validity of the transaction that occurs with a full copy of all the data, by one or more parties.
  GENERATE_PROOF = 2; // The generation of a cyprographic zero-knowledge proof (ZKP) using a full copy of all the data, that allows verification of the transaction by any party without that private data
}

message AttestationRequest {
  string name = 1; // Allows correlation of attestation requests, to attestation results in the domain code
  AttestationType attestation_type = 2; // The type of attestation, which instructs the Paladin engine how to coordinate and submit it
  string algorithm = 3; // An algorithm string to pass to the proof/siging technology to instruct it's operation
  string verifier_type = 4; // When resolving the identity, the verifier type that is required - such as an eth_address
  bytes payload = 5; // A payload (encoded to string) in a format that the proof/signing technology is expecting for the given algorithm string
  string payload_type = 6; // A signing payload type string to pass to the proof/signing technology to instruct the input/output requirements 
  repeated string parties = 7; // The recipient for this attestation request (might be local to the Paladin node, or remote)
  optional int32 threshold = 8; // The minimum number of parties that must produce the attestation to proceed from the assemble to the prepare stage (default is the number of parties)
}

message ResolveVerifierRequest {
  string lookup = 1; // The string to use to look up this party
  string algorithm = 2; // The algorithm for which the verifier is required
  string verifier_type = 3; // The type of verifier that is required (such as eth_address)
}

message ResolvedVerifier {
  string lookup = 1; // The string that was used to look up this verifier
  string algorithm = 2; // The algorithm for which the verifier has been resolved
  string verifier_type = 3; // The type of verifier that was resolved
  string verifier = 4; // The algorithm specific public key identifier (address or other cryptographically significant identifier) that was used by the party to perform the attestation
}

message AttestationResult {
  enum AttestationConstraint {
    ENDORSER_MUST_SUBMIT = 0;
  }
  string name = 1; // The name of the AttestationRequest, so the domain knows the detail of how to process this result
  AttestationType attestation_type = 2; // The type of attestation, which instructs the Paladin engine how to coordinate and submit it
  ResolvedVerifier verifier = 3; // The resolved verifier
  optional string payload_type = 4; // If a payload_type was specified in the request, it is populated in the result
  optional bytes payload = 5; // If the attestation is available
  repeated AttestationConstraint constraints = 6; // If the attester requires this transaction is submitted by their identity
}

message BaseLedgerTransaction {
  string function_abi_json = 1; // The ABI of the function to invoke on the base smart contract, based on processing the user's parameters in the private smart contract layer
  string params_json = 2; // The parameters to pass to the base smart contract function, in JSON format. Paladin will submit this transaction to the base blockchain
}

message BaseLedgerDeployTransaction {
  string constructor_abi_json = 1; // The ABI of the smart contract constructor
  bytes bytecode = 2; // The contract bytecode
  string params_json = 3; // The parameters to pass to the base smart contract constructor, in JSON format. Paladin will submit this transaction to the base blockchain
}

message DomainAPIError {
  string error_message = 1;
}

message OnChainEventLocation {
  string transaction_hash = 1; // The on-chain ethereum hash of the blockchain transaction
  int64 block_number = 2; // The block number of the transaction
  int64 transaction_index = 3; // The index of the transaction within the block
  int64 log_index = 4; // The index of the log of the event that completed the transaction
}

message OnChainEvent {
  OnChainEventLocation location = 1; // the event locator information on the blockchain
  string signature = 2; // 32 byte hex signature
  string solidity_signature = 3; // The friendly solidity signature to match against
  string data_json = 4; // The parsed event data
}

message CompletedTransaction {
  string transaction_id = 1; // The ID of the transaction that has completed (opaque 32 byte identifier)
  OnChainEventLocation location = 2; // the locator information on the blockchain to point at as the source of the confirmation
}

message ContractInfo {
  string contract_address = 1; // The private smart contract address
  bytes contract_config = 2; // Binary config emitted by the constructor event of the contract that is persisted by Paladin and provided on all calls  
}
